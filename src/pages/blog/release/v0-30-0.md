---
title: Release - v0.30.0
abstract: TBD
published: 2024-11-08
layout: blog
---

# Greenwood v0.29.0

**Published: TBD**

<!-- <img src="/assets/blog/serverless.webp" style="display:block; width: 35%; margin: 0 auto;" alt="Serverless function cloud"/> -->

## What's New

TBD, here are three features we'd like to highlight:

1. Import Attributes
1. HTML Web Components
1. CSS Modules ‚Ñ¢Ô∏è

Let's check them out! üëá

## Import Attributes

Although not implemented in [all browsers yet](https://github.com/web-platform-tests/interop/issues/733), **Import Attributes** are a [Stage 4 TC39 standard](https://github.com/tc39/proposal-import-attributes) for extending the ESM syntax to support additional formats on the web; with [**CSS**](https://github.com/web-platform-tests/interop/issues/703) and [**JSON**](https://github.com/web-platform-tests/interop/issues/705) module formats already on the standards track, and [more](https://github.com/WICG/webcomponents/blob/gh-pages/proposals/html-modules-explainer.md) possible in the future. For Greenwood, we have made support for these possible out of the box, with a [configuration flag](/docs/reference/configuration/#polyfills) for providing fallback behavior in the interim (e.g. inlining the contents as a ECMAScript module).

<!-- eslint-disable no-unused-vars -->

```js
// JSON is exported as an object
import data from "./data.json" with { type: "json" };

// CSS is exported as a Constructable StyleSheet
import sheet from "./styles" with { type: "css" };
```

<!-- eslint-enable no-unused-vars -->

For CSS, this works especially well with Shadow DOM based custom elements, as you can now author component styles in vanilla CSS, and adopted them right into your component. This same adoption technique can also include any global ("Light DOM") styles, as now those can be adopted too. Web Standards ftw!

```js
import themeSheet from "../theme.css" with { type: "css" };
import componentSheet from "./header.css" with { type: "css" };

const template = document.createElement("template");

template.innerHTML = `
  <header><!-- content goes here --></header>
`;

export default class Header extends HTMLElement {
  connectedCallback() {
    if (!this.shadowRoot) {
      this.attachShadow({ mode: "open" });
      this.shadowRoot.appendChild(template.content.cloneNode(true));
    }

    this.shadowRoot.adoptedStyleSheets = [themeSheet, componentSheet];
  }
}

customElements.define("x-header", Header);
```

> In the case of CSS Module Scripts, Greenwood will handle linking together any usages of an Import Attribute with any similar references in a `<link>` tag in your HTML, ensuring a single source of truth for both HTML and JS over the network, for the same CSS content.

## HTML Web Components

As detailed in this excellent [blog post](https://blog.jim-nielsen.com/2023/html-web-components/), HTML Web Components are a strategy for leaning more into a less JavaScript dependent flavor of custom elements. Instead of (or in addition to) setting attributes, which would require JavaScript to do anything meaningful with from a content perspective, this options favors nesting the content as HTML, and thus the custom element can be a nice styling or progressively enhanced experience on top. This also provides the benefit of playing nicely with (global / theming) CSS, as styling is not restricted by the encapsulation of Shadow DOM. (think of these as a Light DOM [`<slot>`](https://developer.mozilla.org/en-US/docs/Web/API/Web_components/Using_templates_and_slots), if you will.)

So instead of setting attributes:

```html
<picture-frame img="/path/to/image.png" title="My Image"></picture-frame>
```

Pass HTML as children:

```html
<picture-frame>
  <h3>My Image<h3>
  <img src="/path/to/image.png" alt="My Image">
</picture-frame>
```

With a custom element definition like so:

```js
// CSS can be referenced from HTML, utility libraries, etc
export default class PictureFrame extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      <div class="picture-frame">
        ${this.innerHTML}
      </div>
    `;
  }
}

customElements.define("picture-frame", PictureFrame);
```

> This plugin works great when combined with Greenwood's [**prerendering**](/docs/reference/configuration/#prerender) and [static optimization](/docs/reference/configuration/#optimization) settings for no-runtime, JS based, static HTML generation. Or combine with our CSS Modules ‚Ñ¢Ô∏è plugin. What's our CSS Modules plugin, you ask? Keep reading. üëá

## CSS Modules ‚Ñ¢Ô∏è

A Greenwood plugin for authoring [**CSS Modules ‚Ñ¢Ô∏è**](https://github.com/css-modules/css-modules). It is a modest implementation of [the specification](https://github.com/css-modules/icss). üôÇ

NOT to be confused with CSS Module _Scripts_, which we covered at the start of this post, Greenwood now offers [a plugin](/docs/plugins/css-modules/) for authoring [**CSS Modules ‚Ñ¢Ô∏è**](https://github.com/css-modules/css-modules). This plugin aim to be a modest implementation of [the specification](https://github.com/css-modules/icss). üôÇ

With this plugin, you can create a CSS file that ends in _.module.css_:

```css
/* header.module.css */
.container {
  display: flex;
  justify-content: space-between;
}

.navBarMenu {
  border: 1px solid #020202;
}

.navBarMenuItem {
  & a {
    text-decoration: none;
    color: #020202;
  }
}

@media screen and (min-width: 768px) {
  .container {
    padding: 10px 20px;
  }
}
```

And reference that in your (Light DOM) HTML based Web Component

```js
// header.js
import styles from "./header.module.css";

export default class Header extends HTMLElement {
  connectedCallback() {
    this.innerHTML = `
      <header class="${styles.container}">
        <ul class="${styles.navBarMenu}">
          <li class="${styles.navBarMenuItem}">
            <a href="/about/" title="Documentation">About</a>
          </li>
          <li class="${styles.navBarMenuItem}">
            <a href="/contact/" title="Guides">Contact</a>
          </li>
        </ul>
      </header>
    `;
  }
}

customElements.define("x-header", Header);
```

From there, Greenwood will scope your CSS class names by prefixing them with the filename and a hash, and will then inline that into a `<style>` tag in the HTML while also stripping out references to the _module.css_ file from your calling file.

> This plugin works great when combined with Greenwood's [**prerendering**](/docs/reference/configuration/#prerender) and [static optimization](/docs/reference/configuration/#optimizations) settings for no-runtime, JS based, static HTML generation.

## Honorable Mentions

The above highlights are by no means the only features and enhancements delivered in this release, and so we would like to take a few moments to call out some other great capabilities, including give our :

### Init Refresh

We gave the initial scaffolding output when running our `@greenwood/init` command a refresh; now with some useful starter code and links to the website for common resources. Try it out today using `npx @greenwood/init@latest my-app`!

![Greenwood Init Refresh](/assets/blog/greenwood-init-refresh.webp)

### Lit SSR Enhancements

In this release, we upgraded our Lit SSR plugin to support Lit v3 and addressing some bugs within our implementation. Checkout out the [plugin docs](/docs/plugins/lit-ssr/) for more info our our [demo repo](https://github.com/thescientist13/greenwood-lit-ssr) to see it in action.

### Content as Data

We implemented a pretty significant overhaul of Greenwood's feature set around providing capabilities for leveraging the content of your Greenwood project, deprecating our older "menu" feature with a more useful and general purpose "Collections" feature, introducing a data client, and more. Check out the [full docs](/docs/content-as-data/) to learn more.

---

> Please check out the [full release notes](https://github.com/ProjectEvergreen/greenwood/releases/tag/v0.30.0) for all features and breaking change.

## What's Next

So stay tuned, join [Discord](https://discord.gg/pFbynPar) and [GitHub](https://github.com/ProjectEvergreen) communities to be part of the conversation, and we look forward to seeing you for the next release. ‚úåÔ∏è
