diff --git a/node_modules/wc-compiler/src/dom-shim.js b/node_modules/wc-compiler/src/dom-shim.js
index be289a3..db07eb9 100644
--- a/node_modules/wc-compiler/src/dom-shim.js
+++ b/node_modules/wc-compiler/src/dom-shim.js
@@ -83,6 +83,9 @@ class Document extends Node {
   createDocumentFragment(html) {
     return new DocumentFragment(html);
   }
+
+  querySelector() { }
+  querySelectorAll() { }
 }
 
 // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
@@ -102,6 +105,10 @@ class ShadowRoot extends DocumentFragment {
     super();
     this.mode = options.mode || 'closed';
     this.adoptedStyleSheets = [];
+    // TODO not sure if this is the right base class for these?
+    this.querySelector = noop;
+    this.querySelectorAll = noop;
+    this.getElementById = noop;
   }
 }
 
diff --git a/node_modules/wc-compiler/src/wcc.js b/node_modules/wc-compiler/src/wcc.js
index 35884d4..0b75773 100644
--- a/node_modules/wc-compiler/src/wcc.js
+++ b/node_modules/wc-compiler/src/wcc.js
@@ -33,17 +33,26 @@ async function renderComponentRoots(tree, definitions) {
 
       if (definitions[tagName]) {
         const { moduleURL } = definitions[tagName];
-        const elementInstance = await initializeCustomElement(moduleURL, tagName, node.attrs, definitions);
-        const elementHtml = elementInstance.shadowRoot
-          ? elementInstance.getInnerHTML({ includeShadowRoots: true })
-          : elementInstance.innerHTML;
-        const elementTree = parseFragment(elementHtml);
-
-        node.childNodes = node.childNodes.length === 0
-          ? elementTree.childNodes
-          : [...elementTree.childNodes, ...node.childNodes];
+        const elementInstance = await initializeCustomElement(moduleURL, tagName, node, definitions);
+
+        if (elementInstance) {
+          const hasShadow = elementInstance.shadowRoot;
+          const elementHtml = hasShadow
+            ? elementInstance.getInnerHTML({ includeShadowRoots: true })
+            : elementInstance.innerHTML;
+          const elementTree = parseFragment(elementHtml);
+          const hasLight = elementTree.childNodes > 0;
+
+          node.childNodes = node.childNodes.length === 0 && hasLight && !hasShadow
+            ? elementTree.childNodes
+            : hasShadow
+              ? [...elementTree.childNodes, ...node.childNodes]
+              : elementTree.childNodes;
+        } else {
+          console.warn(`WARNING: customElement <${tagName}> detected but not serialized.  You may not have exported it.`);
+        }
       } else {
-        console.warn(`WARNING: customElement <${tagName}> is not defined.  You may not have imported it yet.`);
+        console.warn(`WARNING: customElement <${tagName}> is not defined.  You may not have imported it.`);
       }
     }
 
@@ -82,7 +91,7 @@ function registerDependencies(moduleURL, definitions, depth = 0) {
       const isBareSpecifier = specifier.indexOf('.') !== 0 && specifier.indexOf('/') !== 0;
       const extension = specifier.split('.').pop();
 
-      // TODO would like to decouple .jsx from the core, ideally
+      // would like to decouple .jsx from the core, ideally
       // https://github.com/ProjectEvergreen/wcc/issues/122
       if (!isBareSpecifier && ['js', 'jsx', 'ts'].includes(extension)) {
         const dependencyModuleURL = new URL(node.source.value, moduleURL);
@@ -138,7 +147,9 @@ async function getTagName(moduleURL) {
   return tagName;
 }
 
-async function initializeCustomElement(elementURL, tagName, attrs = [], definitions = [], isEntry, props = {}) {
+async function initializeCustomElement(elementURL, tagName, node = {}, definitions = [], isEntry, props = {}) {
+  const { attrs = [], childNodes = [] } = node;
+
   if (!tagName) {
     const depth = isEntry ? 1 : 0;
     registerDependencies(elementURL, definitions, depth);
@@ -157,6 +168,34 @@ async function initializeCustomElement(elementURL, tagName, attrs = [], definiti
 
   if (element) {
     const elementInstance = new element(data); // eslint-disable-line new-cap
+    let innerHTML = elementInstance.innerHTML || '';
+
+    // support for HTML (Light DOM) Web Components
+    childNodes.forEach((child) => {
+      const { nodeName, attrs = [] } = child;
+
+      if (nodeName !== '#text') {
+        innerHTML += `<${nodeName}`;
+
+        if (attrs.length > 0) {
+          attrs.forEach(attr => {
+            innerHTML += ` ${attr.name}="${attr.value}"`;
+          });
+        }
+
+        innerHTML += '>';
+
+        child.childNodes.forEach((c) => {
+          if (c.nodeName === '#text') {
+            innerHTML += c.value;
+          }
+        });
+
+        innerHTML += `</${nodeName}>`;
+      }
+    });
+
+    elementInstance.innerHTML = innerHTML;
 
     attrs.forEach((attr) => {
       elementInstance.setAttribute(attr.name, attr.value);
@@ -207,7 +246,7 @@ async function renderFromHTML(html, elements = []) {
   const definitions = [];
 
   for (const url of elements) {
-    await initializeCustomElement(url, undefined, undefined, definitions, true);
+    registerDependencies(url, definitions, 1);
   }
 
   const elementTree = getParse(html)(html);
